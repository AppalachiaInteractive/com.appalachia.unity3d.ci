// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Appalachia.CI.Integration.Packages;
//
//    var npmPackage = NpmPackage.FromJson(jsonString);
using System;
using System.Collections.Generic;

using System.Globalization;
using Appalachia.CI.Integration.Attributes;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Appalachia.CI.Integration.Packages
{
  

    [Serializable]
    [DoNotReorderFields]
    public partial class NpmPackage
    {
        /// <summary>
        /// The name of the package.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Name { get; set; }
        
        /// <summary>
        /// The display  name of the package.
        /// </summary>
        [JsonProperty("displayName", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string DisplayName { get; set; }
        
        /// <summary>
        /// Version must be parseable by node-semver, which is bundled with npm as a dependency.
        /// </summary>
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public string Version { get; set; }
        
        /// <summary>
        /// Unity editor version.
        /// </summary>
        [JsonProperty("unity", NullValueHandling = NullValueHandling.Ignore)]
        public string Unity { get; set; }
        
        /// <summary>
        /// Unity editor release version.
        /// </summary>
        [JsonProperty("unityRelease", NullValueHandling = NullValueHandling.Ignore)]
        public string UnityRelease { get; set; }
        
        /// <summary>
        /// This helps people discover your package, as it's listed in 'npm search'.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// This helps people discover your package as it's listed in 'npm search'.
        /// </summary>
        [JsonProperty("keywords", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Keywords { get; set; }
        
        /// <summary>
        /// The package category.
        /// </summary>
        [JsonProperty("category", NullValueHandling = NullValueHandling.Ignore)]
        public string Category { get; set; }
        

        /// <summary>
        /// You should specify a license for your package so that people know how they are permitted
        /// to use it, and any restrictions you're placing on it.
        /// </summary>
        [JsonProperty("license", NullValueHandling = NullValueHandling.Ignore)]
        public string License { get; set; }

        /// <summary>
        /// DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or {
        /// "license": "(MIT OR Apache-2.0)" } see:
        /// 'https://docs.npmjs.com/files/package.json#license'.
        /// </summary>
        [JsonProperty("licenses", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageLicense[] Licenses { get; set; }

        
        [JsonProperty("author", NullValueHandling = NullValueHandling.Ignore)]
        public Person? Author { get; set; }
      
        /// <summary>
        /// A list of people who contributed to this package.
        /// </summary>
        [JsonProperty("contributors", NullValueHandling = NullValueHandling.Ignore)]
        public Person[] Contributors { get; set; }
        
        /// <summary>
        /// The url to the project homepage.
        /// </summary>
        [JsonProperty("homepage", NullValueHandling = NullValueHandling.Ignore)]
        public string Homepage { get; set; }
        

        /// <summary>
        /// Specify the place where your code lives. This is helpful for people who want to
        /// contribute.
        /// </summary>
        [JsonProperty("repository", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageRepository? Repository { get; set; }

        [JsonProperty("readme", NullValueHandling = NullValueHandling.Ignore)]
        public string Readme { get; set; }

        [JsonProperty("publishConfig", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackagePublishConfig PublishConfig { get; set; }
        
        [JsonProperty("dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Dependencies { get; set; }
        
        [JsonProperty("devDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DevDependencies { get; set; }
        
        [JsonProperty("relatedPackages", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> RelatedPackages { get; set; }
        
        [JsonProperty("upmCi", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> UpmCI { get; set; }
        
        /// <summary>
        /// The 'scripts' member is an object hash of script commands that are run at various times
        /// in the lifecycle of your package. The key is the lifecycle event, and the value is the
        /// command to run at that point.
        /// </summary>
        [JsonProperty("scripts", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Scripts { get; set; }


        /// <summary>
        /// DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or {
        /// "license": "(MIT OR Apache-2.0)" } see:
        /// 'https://docs.npmjs.com/files/package.json#license'.
        /// </summary>
        [JsonProperty("samples", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageSamples[] Samples { get; set; }
        
        /// <summary>
        /// The 'files' field is an array of files to include in your project. If you name a folder
        /// in the array, then it will also include the files inside that folder.
        /// </summary>
        [JsonProperty("files", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Files { get; set; }
        

        [JsonProperty("directories", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageDirectories Directories { get; set; }

        
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public Bin? Bin { get; set; }

        /// <summary>
        /// The url to your project's issue tracker and / or the email address to which issues should
        /// be reported. These are helpful for people who encounter issues with your package.
        /// </summary>
        [JsonProperty("bugs", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageBugs? Bugs { get; set; }

        /// <summary>
        /// Array of package names that will be bundled when publishing the package.
        /// </summary>
        [JsonProperty("bundledDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public BundleDependencies? BundledDependencies { get; set; }

        /// <summary>
        /// DEPRECATED: This field is honored, but "bundledDependencies" is the correct field name.
        /// </summary>
        [JsonProperty("bundleDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public BundleDependencies? BundleDependencies { get; set; }

        /// <summary>
        /// A 'config' hash can be used to set configuration parameters used in package scripts that
        /// persist across upgrades.
        /// </summary>
        [JsonProperty("config", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Config { get; set; }

        /// <summary>
        /// Specify that your code only runs on certain cpu architectures.
        /// </summary>
        [JsonProperty("cpu", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Cpu { get; set; }

        [JsonProperty("dist", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageDist Dist { get; set; }

        [JsonProperty("engines", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Engines { get; set; }

        [JsonProperty("engineStrict", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EngineStrict { get; set; }

        /// <summary>
        /// A module ID with untranspiled code that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("esnext", NullValueHandling = NullValueHandling.Ignore)]
        public Bin? Esnext { get; set; }

        /// <summary>
        /// The "exports" field is used to restrict external access to non-exported module files,
        /// also enables a module to import itself using "name".
        /// </summary>
        [JsonProperty("exports")]
        public NpmPackageExports? Exports { get; set; }

        [JsonProperty("jspm", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFiles Jspm { get; set; }

        /// <summary>
        /// The main field is a module ID that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("main", NullValueHandling = NullValueHandling.Ignore)]
        public string Main { get; set; }

        /// <summary>
        /// A list of people who maintains this package.
        /// </summary>
        [JsonProperty("maintainers", NullValueHandling = NullValueHandling.Ignore)]
        public Person[] Maintainers { get; set; }

        /// <summary>
        /// Specify either a single file or an array of filenames to put in place for the man program
        /// to find.
        /// </summary>
        [JsonProperty("man", NullValueHandling = NullValueHandling.Ignore)]
        public Man? Man { get; set; }

        /// <summary>
        /// An ECMAScript module ID that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("module", NullValueHandling = NullValueHandling.Ignore)]
        public string Module { get; set; }


        [JsonProperty("optionalDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> OptionalDependencies { get; set; }

        /// <summary>
        /// Specify which operating systems your module will run on.
        /// </summary>
        [JsonProperty("os", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Os { get; set; }

        [JsonProperty("peerDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> PeerDependencies { get; set; }

        /// <summary>
        /// When a user installs your package, warnings are emitted if packages specified in
        /// "peerDependencies" are not already installed. The "peerDependenciesMeta" field serves to
        /// provide more information on how your peer dependencies are utilized. Most commonly, it
        /// allows peer dependencies to be marked as optional. Metadata for this field is specified
        /// with a simple hash of the package name to a metadata object.
        /// </summary>
        [JsonProperty("peerDependenciesMeta", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, NpmPackagePeerDependenciesMeta> PeerDependenciesMeta { get; set; }

        /// <summary>
        /// DEPRECATED: This option used to trigger an npm warning, but it will no longer warn. It is
        /// purely there for informational purposes. It is now recommended that you install any
        /// binaries as local devDependencies wherever possible.
        /// </summary>
        [JsonProperty("preferGlobal", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PreferGlobal { get; set; }

        /// <summary>
        /// If set to true, then npm will refuse to publish it.
        /// </summary>
        [JsonProperty("private", NullValueHandling = NullValueHandling.Ignore)]
        public PrivateUnion? Private { get; set; }

        
        /// <summary>
        /// Resolutions is used to support selective version resolutions, which lets you define
        /// custom package versions or ranges inside your dependencies. See:
        /// https://classic.yarnpkg.com/en/docs/selective-version-resolutions
        /// </summary>
        [JsonProperty("resolutions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Resolutions { get; set; }


        /// <summary>
        /// When set to "module", the type field allows a package to specify all .js files within are
        /// ES modules. If the "type" field is omitted or set to "commonjs", all .js files are
        /// treated as CommonJS.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// Set the types property to point to your bundled declaration file.
        /// </summary>
        [JsonProperty("types", NullValueHandling = NullValueHandling.Ignore)]
        public string Types { get; set; }

        /// <summary>
        /// The "typesVersions" field is used since TypeScript 3.1 to support features that were only
        /// made available in newer TypeScript versions.
        /// </summary>
        [JsonProperty("typesVersions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, NpmPackageTypesVersion> TypesVersions { get; set; }

        /// <summary>
        /// Note that the "typings" field is synonymous with "types", and could be used as well.
        /// </summary>
        [JsonProperty("typings", NullValueHandling = NullValueHandling.Ignore)]
        public string Typings { get; set; }


        /// <summary>
        /// Allows packages within a directory to depend on one another using direct linking of local
        /// files. Additionally, dependencies within a workspace are hoisted to the workspace root
        /// when possible to reduce duplication. Note: It's also a good idea to set "private" to true
        /// when using this feature.
        /// </summary>
        [JsonProperty("workspaces", NullValueHandling = NullValueHandling.Ignore)]
        public NpmPackageWorkspaces? Workspaces { get; set; }
    }

    [DoNotReorderFields]
    public partial class PersonClass
    {
        [JsonProperty("email", NullValueHandling = NullValueHandling.Ignore)]
        public string Email { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    [DoNotReorderFields]
    public partial class PurpleBugs
    {
        /// <summary>
        /// The email address to which issues should be reported.
        /// </summary>
        [JsonProperty("email", NullValueHandling = NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// The url to your project's issue tracker.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackageDirectories
    {
        /// <summary>
        /// If you specify a 'bin' directory, then all the files in that folder will be used as the
        /// 'bin' hash.
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public string Bin { get; set; }

        /// <summary>
        /// Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.
        /// </summary>
        [JsonProperty("doc", NullValueHandling = NullValueHandling.Ignore)]
        public string Doc { get; set; }

        /// <summary>
        /// Put example scripts in here. Someday, it might be exposed in some clever way.
        /// </summary>
        [JsonProperty("example", NullValueHandling = NullValueHandling.Ignore)]
        public string Example { get; set; }

        /// <summary>
        /// Tell people where the bulk of your library is. Nothing special is done with the lib
        /// folder in any way, but it's useful meta info.
        /// </summary>
        [JsonProperty("lib", NullValueHandling = NullValueHandling.Ignore)]
        public string Lib { get; set; }

        /// <summary>
        /// A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.
        /// </summary>
        [JsonProperty("man", NullValueHandling = NullValueHandling.Ignore)]
        public string Man { get; set; }

        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackageDist
    {
        [JsonProperty("shasum", NullValueHandling = NullValueHandling.Ignore)]
        public string Shasum { get; set; }

        [JsonProperty("tarball", NullValueHandling = NullValueHandling.Ignore)]
        public string Tarball { get; set; }
    }

    [DoNotReorderFields]
    /// <summary>
    /// Used to specify conditional exports, note that Conditional exports are unsupported in
    /// older environments, so it's recommended to use the fallback array option if support for
    /// those environments is a concern.
    ///
    /// The module path that is resolved when the module specifier matches "name", shadows the
    /// "main" field.
    /// </summary>
    public partial class PackageExportsEntryPackageExportsEntryObject
    {
        /// <summary>
        /// The module path that is resolved when no other export type matches.
        /// </summary>
        [JsonProperty("default")]
        public PackageExportsEntryOrFallback? Default { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as an ECMAScript module
        /// using an `import` declaration or the dynamic `import(...)` function.
        /// </summary>
        [JsonProperty("import")]
        public PackageExportsEntryOrFallback? Import { get; set; }

        /// <summary>
        /// The module path that is resolved when this environment is Node.js.
        /// </summary>
        [JsonProperty("node")]
        public PackageExportsEntryOrFallback? Node { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as a CommonJS module
        /// using the `require(...)` function.
        /// </summary>
        [JsonProperty("require")]
        public PackageExportsEntryOrFallback? Require { get; set; }
    }

    [DoNotReorderFields]
    /// <summary>
    /// Used to specify conditional exports, note that Conditional exports are unsupported in
    /// older environments, so it's recommended to use the fallback array option if support for
    /// those environments is a concern.
    ///
    /// The module path that is resolved when the module specifier matches "name", shadows the
    /// "main" field.
    /// </summary>
    public partial class PurplePackageExportsEntryObject
    {
        /// <summary>
        /// The module path that is resolved when the module specifier matches "name", shadows the
        /// "main" field.
        /// </summary>
        [JsonProperty(".")]
        public PackageExportsEntryOrFallback? Empty { get; set; }

        /// <summary>
        /// The module path prefix that is resolved when the module specifier starts with "name/",
        /// set to "./" to allow external modules to import any subpath.
        /// </summary>
        [JsonProperty("./")]
        public PackageExportsEntryOrFallback? PackageExportsEntryObject { get; set; }

        /// <summary>
        /// The module path that is resolved when no other export type matches.
        /// </summary>
        [JsonProperty("default")]
        public PackageExportsEntryOrFallback? Default { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as an ECMAScript module
        /// using an `import` declaration or the dynamic `import(...)` function.
        /// </summary>
        [JsonProperty("import")]
        public PackageExportsEntryOrFallback? Import { get; set; }

        /// <summary>
        /// The module path that is resolved when this environment is Node.js.
        /// </summary>
        [JsonProperty("node")]
        public PackageExportsEntryOrFallback? Node { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as a CommonJS module
        /// using the `require(...)` function.
        /// </summary>
        [JsonProperty("require")]
        public PackageExportsEntryOrFallback? Require { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFiles
    {
        [JsonProperty("author", NullValueHandling = NullValueHandling.Ignore)]
        public Person? Author { get; set; }

        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public Bin? Bin { get; set; }

        /// <summary>
        /// The url to your project's issue tracker and / or the email address to which issues should
        /// be reported. These are helpful for people who encounter issues with your package.
        /// </summary>
        [JsonProperty("bugs", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesBugs? Bugs { get; set; }

        /// <summary>
        /// Array of package names that will be bundled when publishing the package.
        /// </summary>
        [JsonProperty("bundledDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public BundleDependencies? BundledDependencies { get; set; }

        /// <summary>
        /// DEPRECATED: This field is honored, but "bundledDependencies" is the correct field name.
        /// </summary>
        [JsonProperty("bundleDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public BundleDependencies? BundleDependencies { get; set; }

        /// <summary>
        /// A 'config' hash can be used to set configuration parameters used in package scripts that
        /// persist across upgrades.
        /// </summary>
        [JsonProperty("config", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Config { get; set; }

        /// <summary>
        /// A list of people who contributed to this package.
        /// </summary>
        [JsonProperty("contributors", NullValueHandling = NullValueHandling.Ignore)]
        public Person[] Contributors { get; set; }

        /// <summary>
        /// Specify that your code only runs on certain cpu architectures.
        /// </summary>
        [JsonProperty("cpu", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Cpu { get; set; }

        [JsonProperty("dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Dependencies { get; set; }

        /// <summary>
        /// This helps people discover your package, as it's listed in 'npm search'.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("devDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> DevDependencies { get; set; }

        [JsonProperty("directories", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesDirectories Directories { get; set; }

        [JsonProperty("dist", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesDist Dist { get; set; }

        [JsonProperty("engines", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Engines { get; set; }

        [JsonProperty("engineStrict", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EngineStrict { get; set; }

        /// <summary>
        /// A module ID with untranspiled code that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("esnext", NullValueHandling = NullValueHandling.Ignore)]
        public Bin? Esnext { get; set; }

        /// <summary>
        /// The "exports" field is used to restrict external access to non-exported module files,
        /// also enables a module to import itself using "name".
        /// </summary>
        [JsonProperty("exports")]
        public JsonSchemaForNpmPackageJsonFilesExports? Exports { get; set; }

        /// <summary>
        /// The 'files' field is an array of files to include in your project. If you name a folder
        /// in the array, then it will also include the files inside that folder.
        /// </summary>
        [JsonProperty("files", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Files { get; set; }

        /// <summary>
        /// The url to the project homepage.
        /// </summary>
        [JsonProperty("homepage", NullValueHandling = NullValueHandling.Ignore)]
        public string Homepage { get; set; }

        [JsonProperty("jspm", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFiles Jspm { get; set; }

        /// <summary>
        /// This helps people discover your package as it's listed in 'npm search'.
        /// </summary>
        [JsonProperty("keywords", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Keywords { get; set; }

        /// <summary>
        /// You should specify a license for your package so that people know how they are permitted
        /// to use it, and any restrictions you're placing on it.
        /// </summary>
        [JsonProperty("license", NullValueHandling = NullValueHandling.Ignore)]
        public string License { get; set; }

        /// <summary>
        /// DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or {
        /// "license": "(MIT OR Apache-2.0)" } see:
        /// 'https://docs.npmjs.com/files/package.json#license'.
        /// </summary>
        [JsonProperty("licenses", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesLicense[] Licenses { get; set; }

        /// <summary>
        /// The main field is a module ID that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("main", NullValueHandling = NullValueHandling.Ignore)]
        public string Main { get; set; }

        /// <summary>
        /// A list of people who maintains this package.
        /// </summary>
        [JsonProperty("maintainers", NullValueHandling = NullValueHandling.Ignore)]
        public Person[] Maintainers { get; set; }

        /// <summary>
        /// Specify either a single file or an array of filenames to put in place for the man program
        /// to find.
        /// </summary>
        [JsonProperty("man", NullValueHandling = NullValueHandling.Ignore)]
        public Man? Man { get; set; }

        /// <summary>
        /// An ECMAScript module ID that is the primary entry point to your program.
        /// </summary>
        [JsonProperty("module", NullValueHandling = NullValueHandling.Ignore)]
        public string Module { get; set; }

        /// <summary>
        /// The name of the package.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        [JsonProperty("optionalDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> OptionalDependencies { get; set; }

        /// <summary>
        /// Specify which operating systems your module will run on.
        /// </summary>
        [JsonProperty("os", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Os { get; set; }

        [JsonProperty("peerDependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> PeerDependencies { get; set; }

        /// <summary>
        /// When a user installs your package, warnings are emitted if packages specified in
        /// "peerDependencies" are not already installed. The "peerDependenciesMeta" field serves to
        /// provide more information on how your peer dependencies are utilized. Most commonly, it
        /// allows peer dependencies to be marked as optional. Metadata for this field is specified
        /// with a simple hash of the package name to a metadata object.
        /// </summary>
        [JsonProperty("peerDependenciesMeta", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, JsonSchemaForNpmPackageJsonFilesPeerDependenciesMeta> PeerDependenciesMeta { get; set; }

        /// <summary>
        /// DEPRECATED: This option used to trigger an npm warning, but it will no longer warn. It is
        /// purely there for informational purposes. It is now recommended that you install any
        /// binaries as local devDependencies wherever possible.
        /// </summary>
        [JsonProperty("preferGlobal", NullValueHandling = NullValueHandling.Ignore)]
        public bool? PreferGlobal { get; set; }

        /// <summary>
        /// If set to true, then npm will refuse to publish it.
        /// </summary>
        [JsonProperty("private", NullValueHandling = NullValueHandling.Ignore)]
        public PrivateUnion? Private { get; set; }

        [JsonProperty("publishConfig", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesPublishConfig PublishConfig { get; set; }

        [JsonProperty("readme", NullValueHandling = NullValueHandling.Ignore)]
        public string Readme { get; set; }

        /// <summary>
        /// Specify the place where your code lives. This is helpful for people who want to
        /// contribute.
        /// </summary>
        [JsonProperty("repository", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesRepository? Repository { get; set; }

        /// <summary>
        /// Resolutions is used to support selective version resolutions, which lets you define
        /// custom package versions or ranges inside your dependencies. See:
        /// https://classic.yarnpkg.com/en/docs/selective-version-resolutions
        /// </summary>
        [JsonProperty("resolutions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Resolutions { get; set; }

        /// <summary>
        /// The 'scripts' member is an object hash of script commands that are run at various times
        /// in the lifecycle of your package. The key is the lifecycle event, and the value is the
        /// command to run at that point.
        /// </summary>
        [JsonProperty("scripts", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Scripts { get; set; }

        /// <summary>
        /// When set to "module", the type field allows a package to specify all .js files within are
        /// ES modules. If the "type" field is omitted or set to "commonjs", all .js files are
        /// treated as CommonJS.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// Set the types property to point to your bundled declaration file.
        /// </summary>
        [JsonProperty("types", NullValueHandling = NullValueHandling.Ignore)]
        public string Types { get; set; }

        /// <summary>
        /// The "typesVersions" field is used since TypeScript 3.1 to support features that were only
        /// made available in newer TypeScript versions.
        /// </summary>
        [JsonProperty("typesVersions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, JsonSchemaForNpmPackageJsonFilesTypesVersion> TypesVersions { get; set; }

        /// <summary>
        /// Note that the "typings" field is synonymous with "types", and could be used as well.
        /// </summary>
        [JsonProperty("typings", NullValueHandling = NullValueHandling.Ignore)]
        public string Typings { get; set; }

        /// <summary>
        /// Version must be parseable by node-semver, which is bundled with npm as a dependency.
        /// </summary>
        [JsonProperty("version", NullValueHandling = NullValueHandling.Ignore)]
        public string Version { get; set; }

        /// <summary>
        /// Allows packages within a directory to depend on one another using direct linking of local
        /// files. Additionally, dependencies within a workspace are hoisted to the workspace root
        /// when possible to reduce duplication. Note: It's also a good idea to set "private" to true
        /// when using this feature.
        /// </summary>
        [JsonProperty("workspaces", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForNpmPackageJsonFilesWorkspaces? Workspaces { get; set; }
    }

    [DoNotReorderFields]
    public partial class FluffyBugs
    {
        /// <summary>
        /// The email address to which issues should be reported.
        /// </summary>
        [JsonProperty("email", NullValueHandling = NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// The url to your project's issue tracker.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFilesDirectories
    {
        /// <summary>
        /// If you specify a 'bin' directory, then all the files in that folder will be used as the
        /// 'bin' hash.
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public string Bin { get; set; }

        /// <summary>
        /// Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.
        /// </summary>
        [JsonProperty("doc", NullValueHandling = NullValueHandling.Ignore)]
        public string Doc { get; set; }

        /// <summary>
        /// Put example scripts in here. Someday, it might be exposed in some clever way.
        /// </summary>
        [JsonProperty("example", NullValueHandling = NullValueHandling.Ignore)]
        public string Example { get; set; }

        /// <summary>
        /// Tell people where the bulk of your library is. Nothing special is done with the lib
        /// folder in any way, but it's useful meta info.
        /// </summary>
        [JsonProperty("lib", NullValueHandling = NullValueHandling.Ignore)]
        public string Lib { get; set; }

        /// <summary>
        /// A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.
        /// </summary>
        [JsonProperty("man", NullValueHandling = NullValueHandling.Ignore)]
        public string Man { get; set; }

        [JsonProperty("test", NullValueHandling = NullValueHandling.Ignore)]
        public string Test { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFilesDist
    {
        [JsonProperty("shasum", NullValueHandling = NullValueHandling.Ignore)]
        public string Shasum { get; set; }

        [JsonProperty("tarball", NullValueHandling = NullValueHandling.Ignore)]
        public string Tarball { get; set; }
    }

    [DoNotReorderFields]
    /// <summary>
    /// Used to specify conditional exports, note that Conditional exports are unsupported in
    /// older environments, so it's recommended to use the fallback array option if support for
    /// those environments is a concern.
    ///
    /// The module path that is resolved when the module specifier matches "name", shadows the
    /// "main" field.
    /// </summary>
    public partial class FluffyPackageExportsEntryObject
    {
        /// <summary>
        /// The module path that is resolved when the module specifier matches "name", shadows the
        /// "main" field.
        /// </summary>
        [JsonProperty(".")]
        public PackageExportsEntryOrFallback? Empty { get; set; }

        /// <summary>
        /// The module path prefix that is resolved when the module specifier starts with "name/",
        /// set to "./" to allow external modules to import any subpath.
        /// </summary>
        [JsonProperty("./")]
        public PackageExportsEntryOrFallback? PackageExportsEntryObject { get; set; }

        /// <summary>
        /// The module path that is resolved when no other export type matches.
        /// </summary>
        [JsonProperty("default")]
        public PackageExportsEntryOrFallback? Default { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as an ECMAScript module
        /// using an `import` declaration or the dynamic `import(...)` function.
        /// </summary>
        [JsonProperty("import")]
        public PackageExportsEntryOrFallback? Import { get; set; }

        /// <summary>
        /// The module path that is resolved when this environment is Node.js.
        /// </summary>
        [JsonProperty("node")]
        public PackageExportsEntryOrFallback? Node { get; set; }

        /// <summary>
        /// The module path that is resolved when this specifier is imported as a CommonJS module
        /// using the `require(...)` function.
        /// </summary>
        [JsonProperty("require")]
        public PackageExportsEntryOrFallback? Require { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFilesLicense
    {
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFilesPeerDependenciesMeta
    {
        /// <summary>
        /// Specifies that this peer dependency is optional and should not be installed automatically.
        /// </summary>
        [JsonProperty("optional", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    }

    [DoNotReorderFields]
    public partial class JsonSchemaForNpmPackageJsonFilesPublishConfig
    {
        [JsonProperty("access", NullValueHandling = NullValueHandling.Ignore)]
        public Access? Access { get; set; }

        [JsonProperty("registry", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Registry { get; set; }

        [JsonProperty("tag", NullValueHandling = NullValueHandling.Ignore)]
        public string Tag { get; set; }
    }

    [DoNotReorderFields]
    public partial class PurpleRepository
    {
        [JsonProperty("directory", NullValueHandling = NullValueHandling.Ignore)]
        public string Directory { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }
    
    [DoNotReorderFields]
    /// <summary>
    /// Contains overrides for the TypeScript version that matches the version range matching the
    /// property key.
    /// </summary>
    public partial class JsonSchemaForNpmPackageJsonFilesTypesVersion
    {
        /// <summary>
        /// Maps all file paths to the file paths specified in the array.
        /// </summary>
        [JsonProperty("*", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Empty { get; set; }
    }

    [DoNotReorderFields]
    public partial class PurpleWorkspaces
    {
        /// <summary>
        /// Packages to block from hoisting to the workspace root. Currently only supported in Yarn
        /// only.
        /// </summary>
        [JsonProperty("nohoist", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Nohoist { get; set; }

        /// <summary>
        /// Workspace package paths. Glob patterns are supported.
        /// </summary>
        [JsonProperty("packages", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Packages { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackageSamples
    {
        [JsonProperty("displayName", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayName { get; set; }
        
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }
        
        [JsonProperty("path", NullValueHandling = NullValueHandling.Ignore)]
        public string Path { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackageLicense
    {
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Url { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackagePeerDependenciesMeta
    {
        /// <summary>
        /// Specifies that this peer dependency is optional and should not be installed automatically.
        /// </summary>
        [JsonProperty("optional", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    }

    [DoNotReorderFields]
    public partial class NpmPackagePublishConfig
    {
        [JsonProperty("access", NullValueHandling = NullValueHandling.Ignore)]
        public Access? Access { get; set; }

        [JsonProperty("registry", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Registry { get; set; }

        [JsonProperty("tag", NullValueHandling = NullValueHandling.Ignore)]
        public string Tag { get; set; }
    }

    [DoNotReorderFields]
    public partial class FluffyRepository
    {
        [JsonProperty("directory", NullValueHandling = NullValueHandling.Ignore)]
        public string Directory { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    [DoNotReorderFields]
    /// <summary>
    /// Contains overrides for the TypeScript version that matches the version range matching the
    /// property key.
    /// </summary>
    public partial class NpmPackageTypesVersion
    {
        /// <summary>
        /// Maps all file paths to the file paths specified in the array.
        /// </summary>
        [JsonProperty("*", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Empty { get; set; }
    }

    [DoNotReorderFields]
    public partial class FluffyWorkspaces
    {
        /// <summary>
        /// Packages to block from hoisting to the workspace root. Currently only supported in Yarn
        /// only.
        /// </summary>
        [JsonProperty("nohoist", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Nohoist { get; set; }

        /// <summary>
        /// Workspace package paths. Glob patterns are supported.
        /// </summary>
        [JsonProperty("packages", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Packages { get; set; }
    }

    [DoNotReorderFields]
    public enum PrivateEnum { False, True };

    [DoNotReorderFields]
    public enum Access { Public, Restricted };

    [DoNotReorderFields]
    /// <summary>
    /// When set to "module", the type field allows a package to specify all .js files within are
    /// ES modules. If the "type" field is omitted or set to "commonjs", all .js files are
    /// treated as CommonJS.
    /// </summary>
    public enum TypeEnum { Commonjs, Module, Library };

    [DoNotReorderFields]
    /// <summary>
    /// A person who has been involved in creating or maintaining this package.
    /// </summary>
    public partial struct Person
    {
        public PersonClass PersonClass;
        public string String;

        public static implicit operator Person(PersonClass PersonClass) => new Person { PersonClass = PersonClass };
        public static implicit operator Person(string String) => new Person { String = String };
    }

    [DoNotReorderFields]
    /// <summary>
    /// A module ID with untranspiled code that is the primary entry point to your program.
    /// </summary>
    public partial struct Bin
    {
        public string String;
        public Dictionary<string, string> StringMap;

        public static implicit operator Bin(string String) => new Bin { String = String };
        public static implicit operator Bin(Dictionary<string, string> StringMap) => new Bin { StringMap = StringMap };
    }

    [DoNotReorderFields]
    /// <summary>
    /// The url to your project's issue tracker and / or the email address to which issues should
    /// be reported. These are helpful for people who encounter issues with your package.
    /// </summary>
    public partial struct NpmPackageBugs
    {
        public PurpleBugs PurpleBugs;
        public string String;

        public static implicit operator NpmPackageBugs(PurpleBugs PurpleBugs) => new NpmPackageBugs { PurpleBugs = PurpleBugs };
        public static implicit operator NpmPackageBugs(string String) => new NpmPackageBugs { String = String };
    }

    [DoNotReorderFields]
    /// <summary>
    /// DEPRECATED: This field is honored, but "bundledDependencies" is the correct field name.
    ///
    /// Array of package names that will be bundled when publishing the package.
    /// </summary>
    public partial struct BundleDependencies
    {
        public bool? Bool;
        public string[] StringArray;

        public static implicit operator BundleDependencies(bool Bool) => new BundleDependencies { Bool = Bool };
        public static implicit operator BundleDependencies(string[] StringArray) => new BundleDependencies { StringArray = StringArray };
    }

    [DoNotReorderFields]
    /// <summary>
    /// Used to allow fallbacks in case this environment doesn't support the preceding entries.
    /// </summary>
    public partial struct PackageExportsEntry
    {
        public PackageExportsEntryPackageExportsEntryObject PackageExportsEntryPackageExportsEntryObject;
        public string String;

        public static implicit operator PackageExportsEntry(PackageExportsEntryPackageExportsEntryObject PackageExportsEntryPackageExportsEntryObject) => new PackageExportsEntry { PackageExportsEntryPackageExportsEntryObject = PackageExportsEntryPackageExportsEntryObject };
        public static implicit operator PackageExportsEntry(string String) => new PackageExportsEntry { String = String };
        public bool IsNull => PackageExportsEntryPackageExportsEntryObject == null && String == null;
    }

    [DoNotReorderFields]
    /// <summary>
    /// The module path that is resolved when the module specifier matches "name", shadows the
    /// "main" field.
    ///
    /// The module path that is resolved when no other export type matches.
    ///
    /// The module path that is resolved when this specifier is imported as an ECMAScript module
    /// using an `import` declaration or the dynamic `import(...)` function.
    ///
    /// The module path that is resolved when this environment is Node.js.
    ///
    /// The module path that is resolved when this specifier is imported as a CommonJS module
    /// using the `require(...)` function.
    ///
    /// The module path prefix that is resolved when the module specifier starts with "name/",
    /// set to "./" to allow external modules to import any subpath.
    /// </summary>
    public partial struct PackageExportsEntryOrFallback
    {
        public PackageExportsEntry[] AnythingArray;
        public PackageExportsEntryPackageExportsEntryObject PackageExportsEntryPackageExportsEntryObject;
        public string String;

        public static implicit operator PackageExportsEntryOrFallback(PackageExportsEntry[] AnythingArray) => new PackageExportsEntryOrFallback { AnythingArray = AnythingArray };
        public static implicit operator PackageExportsEntryOrFallback(PackageExportsEntryPackageExportsEntryObject PackageExportsEntryPackageExportsEntryObject) => new PackageExportsEntryOrFallback { PackageExportsEntryPackageExportsEntryObject = PackageExportsEntryPackageExportsEntryObject };
        public static implicit operator PackageExportsEntryOrFallback(string String) => new PackageExportsEntryOrFallback { String = String };
        public bool IsNull => AnythingArray == null && PackageExportsEntryPackageExportsEntryObject == null && String == null;
    }

    [DoNotReorderFields]
    /// <summary>
    /// The "exports" field is used to restrict external access to non-exported module files,
    /// also enables a module to import itself using "name".
    /// </summary>
    public partial struct NpmPackageExports
    {
        public PackageExportsEntry[] AnythingArray;
        public PurplePackageExportsEntryObject PurplePackageExportsEntryObject;
        public string String;

        public static implicit operator NpmPackageExports(PackageExportsEntry[] AnythingArray) => new NpmPackageExports { AnythingArray = AnythingArray };
        public static implicit operator NpmPackageExports(PurplePackageExportsEntryObject PurplePackageExportsEntryObject) => new NpmPackageExports { PurplePackageExportsEntryObject = PurplePackageExportsEntryObject };
        public static implicit operator NpmPackageExports(string String) => new NpmPackageExports { String = String };
        public bool IsNull => AnythingArray == null && PurplePackageExportsEntryObject == null && String == null;
    }

    [DoNotReorderFields]
    /// <summary>
    /// The url to your project's issue tracker and / or the email address to which issues should
    /// be reported. These are helpful for people who encounter issues with your package.
    /// </summary>
    public partial struct JsonSchemaForNpmPackageJsonFilesBugs
    {
        public FluffyBugs FluffyBugs;
        public string String;

        public static implicit operator JsonSchemaForNpmPackageJsonFilesBugs(FluffyBugs FluffyBugs) => new JsonSchemaForNpmPackageJsonFilesBugs { FluffyBugs = FluffyBugs };
        public static implicit operator JsonSchemaForNpmPackageJsonFilesBugs(string String) => new JsonSchemaForNpmPackageJsonFilesBugs { String = String };
    }

    [DoNotReorderFields]
    /// <summary>
    /// The "exports" field is used to restrict external access to non-exported module files,
    /// also enables a module to import itself using "name".
    /// </summary>
    public partial struct JsonSchemaForNpmPackageJsonFilesExports
    {
        public PackageExportsEntry[] AnythingArray;
        public FluffyPackageExportsEntryObject FluffyPackageExportsEntryObject;
        public string String;

        public static implicit operator JsonSchemaForNpmPackageJsonFilesExports(PackageExportsEntry[] AnythingArray) => new JsonSchemaForNpmPackageJsonFilesExports { AnythingArray = AnythingArray };
        public static implicit operator JsonSchemaForNpmPackageJsonFilesExports(FluffyPackageExportsEntryObject FluffyPackageExportsEntryObject) => new JsonSchemaForNpmPackageJsonFilesExports { FluffyPackageExportsEntryObject = FluffyPackageExportsEntryObject };
        public static implicit operator JsonSchemaForNpmPackageJsonFilesExports(string String) => new JsonSchemaForNpmPackageJsonFilesExports { String = String };
        public bool IsNull => AnythingArray == null && FluffyPackageExportsEntryObject == null && String == null;
    }

    [DoNotReorderFields]
    /// <summary>
    /// Specify either a single file or an array of filenames to put in place for the man program
    /// to find.
    /// </summary>
    public partial struct Man
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Man(string String) => new Man { String = String };
        public static implicit operator Man(string[] StringArray) => new Man { StringArray = StringArray };
    }

    [DoNotReorderFields]
    public partial struct PrivateUnion
    {
        public bool? Bool;
        public PrivateEnum? Enum;

        public static implicit operator PrivateUnion(bool Bool) => new PrivateUnion { Bool = Bool };
        public static implicit operator PrivateUnion(PrivateEnum Enum) => new PrivateUnion { Enum = Enum };
    }

    [DoNotReorderFields]
    /// <summary>
    /// Specify the place where your code lives. This is helpful for people who want to
    /// contribute.
    /// </summary>
    public partial struct JsonSchemaForNpmPackageJsonFilesRepository
    {
        public PurpleRepository PurpleRepository;
        public string String;

        public static implicit operator JsonSchemaForNpmPackageJsonFilesRepository(PurpleRepository PurpleRepository) => new JsonSchemaForNpmPackageJsonFilesRepository { PurpleRepository = PurpleRepository };
        public static implicit operator JsonSchemaForNpmPackageJsonFilesRepository(string String) => new JsonSchemaForNpmPackageJsonFilesRepository { String = String };
    }

    [DoNotReorderFields]
    /// <summary>
    /// Allows packages within a directory to depend on one another using direct linking of local
    /// files. Additionally, dependencies within a workspace are hoisted to the workspace root
    /// when possible to reduce duplication. Note: It's also a good idea to set "private" to true
    /// when using this feature.
    /// </summary>
    public partial struct JsonSchemaForNpmPackageJsonFilesWorkspaces
    {
        public PurpleWorkspaces PurpleWorkspaces;
        public string[] StringArray;

        public static implicit operator JsonSchemaForNpmPackageJsonFilesWorkspaces(PurpleWorkspaces PurpleWorkspaces) => new JsonSchemaForNpmPackageJsonFilesWorkspaces { PurpleWorkspaces = PurpleWorkspaces };
        public static implicit operator JsonSchemaForNpmPackageJsonFilesWorkspaces(string[] StringArray) => new JsonSchemaForNpmPackageJsonFilesWorkspaces { StringArray = StringArray };
    }

    [DoNotReorderFields]
    /// <summary>
    /// Specify the place where your code lives. This is helpful for people who want to
    /// contribute.
    /// </summary>
    public partial struct NpmPackageRepository
    {
        public FluffyRepository FluffyRepository;
        public string String;

        public static implicit operator NpmPackageRepository(FluffyRepository FluffyRepository) => new NpmPackageRepository { FluffyRepository = FluffyRepository };
        public static implicit operator NpmPackageRepository(string String) => new NpmPackageRepository { String = String };
    }

    [DoNotReorderFields]
    /// <summary>
    /// Allows packages within a directory to depend on one another using direct linking of local
    /// files. Additionally, dependencies within a workspace are hoisted to the workspace root
    /// when possible to reduce duplication. Note: It's also a good idea to set "private" to true
    /// when using this feature.
    /// </summary>
    public partial struct NpmPackageWorkspaces
    {
        public FluffyWorkspaces FluffyWorkspaces;
        public string[] StringArray;

        public static implicit operator NpmPackageWorkspaces(FluffyWorkspaces FluffyWorkspaces) => new NpmPackageWorkspaces { FluffyWorkspaces = FluffyWorkspaces };
        public static implicit operator NpmPackageWorkspaces(string[] StringArray) => new NpmPackageWorkspaces { StringArray = StringArray };
    }

    public partial class NpmPackage
    {
        public static NpmPackage FromJson(string json) => JsonConvert.DeserializeObject<NpmPackage>(json, Appalachia.CI.Integration.Packages.Converter.Settings);

        public override string ToString()
        {
            return $"{Name}: {Version}";
        }
    }

    [DoNotReorderFields]
    public static class Serialize
    {
        public static string ToJson(this NpmPackage self) => JsonConvert.SerializeObject(self, Appalachia.CI.Integration.Packages.Converter.Settings);
    }

    [DoNotReorderFields]
    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None, 
            Formatting = Formatting.Indented, 
            Converters =
            {
                PersonConverter.Singleton,
                BinConverter.Singleton,
                NpmPackageBugsConverter.Singleton,
                BundleDependenciesConverter.Singleton,
                NpmPackageExportsConverter.Singleton,
                PackageExportsEntryConverter.Singleton,
                PackageExportsEntryOrFallbackConverter.Singleton,
                JsonSchemaForNpmPackageJsonFilesBugsConverter.Singleton,
                JsonSchemaForNpmPackageJsonFilesExportsConverter.Singleton,
                ManConverter.Singleton,
                PrivateUnionConverter.Singleton,
                PrivateEnumConverter.Singleton,
                AccessConverter.Singleton,
                JsonSchemaForNpmPackageJsonFilesRepositoryConverter.Singleton,
                TypeEnumConverter.Singleton,
                JsonSchemaForNpmPackageJsonFilesWorkspacesConverter.Singleton,
                NpmPackageRepositoryConverter.Singleton,
                NpmPackageWorkspacesConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    [DoNotReorderFields]
    internal class PersonConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Person) || t == typeof(Person?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Person { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PersonClass>(reader);
                    return new Person { PersonClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Person");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Person)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.PersonClass != null)
            {
                serializer.Serialize(writer, value.PersonClass);
                return;
            }
            throw new Exception("Cannot marshal type Person");
        }

        public static readonly PersonConverter Singleton = new PersonConverter();
    }

    [DoNotReorderFields]
    internal class BinConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Bin) || t == typeof(Bin?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Bin { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, string>>(reader);
                    return new Bin { StringMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type Bin");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Bin)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringMap != null)
            {
                serializer.Serialize(writer, value.StringMap);
                return;
            }
            throw new Exception("Cannot marshal type Bin");
        }

        public static readonly BinConverter Singleton = new BinConverter();
    }

    [DoNotReorderFields]
    internal class NpmPackageBugsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NpmPackageBugs) || t == typeof(NpmPackageBugs?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new NpmPackageBugs { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleBugs>(reader);
                    return new NpmPackageBugs { PurpleBugs = objectValue };
            }
            throw new Exception("Cannot unmarshal type NpmPackageBugs");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NpmPackageBugs)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.PurpleBugs != null)
            {
                serializer.Serialize(writer, value.PurpleBugs);
                return;
            }
            throw new Exception("Cannot marshal type NpmPackageBugs");
        }

        public static readonly NpmPackageBugsConverter Singleton = new NpmPackageBugsConverter();
    }

    [DoNotReorderFields]
    internal class BundleDependenciesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BundleDependencies) || t == typeof(BundleDependencies?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new BundleDependencies { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new BundleDependencies { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type BundleDependencies");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (BundleDependencies)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type BundleDependencies");
        }

        public static readonly BundleDependenciesConverter Singleton = new BundleDependenciesConverter();
    }

    [DoNotReorderFields]
    internal class NpmPackageExportsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NpmPackageExports) || t == typeof(NpmPackageExports?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new NpmPackageExports { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new NpmPackageExports { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurplePackageExportsEntryObject>(reader);
                    return new NpmPackageExports { PurplePackageExportsEntryObject = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<PackageExportsEntry[]>(reader);
                    return new NpmPackageExports { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type NpmPackageExports");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NpmPackageExports)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.PurplePackageExportsEntryObject != null)
            {
                serializer.Serialize(writer, value.PurplePackageExportsEntryObject);
                return;
            }
            throw new Exception("Cannot marshal type NpmPackageExports");
        }

        public static readonly NpmPackageExportsConverter Singleton = new NpmPackageExportsConverter();
    }

    [DoNotReorderFields]
    internal class PackageExportsEntryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PackageExportsEntry) || t == typeof(PackageExportsEntry?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new PackageExportsEntry { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new PackageExportsEntry { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PackageExportsEntryPackageExportsEntryObject>(reader);
                    return new PackageExportsEntry { PackageExportsEntryPackageExportsEntryObject = objectValue };
            }
            throw new Exception("Cannot unmarshal type PackageExportsEntry");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PackageExportsEntry)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.PackageExportsEntryPackageExportsEntryObject != null)
            {
                serializer.Serialize(writer, value.PackageExportsEntryPackageExportsEntryObject);
                return;
            }
            throw new Exception("Cannot marshal type PackageExportsEntry");
        }

        public static readonly PackageExportsEntryConverter Singleton = new PackageExportsEntryConverter();
    }

    [DoNotReorderFields]
    internal class PackageExportsEntryOrFallbackConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PackageExportsEntryOrFallback) || t == typeof(PackageExportsEntryOrFallback?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new PackageExportsEntryOrFallback { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new PackageExportsEntryOrFallback { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PackageExportsEntryPackageExportsEntryObject>(reader);
                    return new PackageExportsEntryOrFallback { PackageExportsEntryPackageExportsEntryObject = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<PackageExportsEntry[]>(reader);
                    return new PackageExportsEntryOrFallback { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PackageExportsEntryOrFallback");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PackageExportsEntryOrFallback)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.PackageExportsEntryPackageExportsEntryObject != null)
            {
                serializer.Serialize(writer, value.PackageExportsEntryPackageExportsEntryObject);
                return;
            }
            throw new Exception("Cannot marshal type PackageExportsEntryOrFallback");
        }

        public static readonly PackageExportsEntryOrFallbackConverter Singleton = new PackageExportsEntryOrFallbackConverter();
    }

    [DoNotReorderFields]
    internal class JsonSchemaForNpmPackageJsonFilesBugsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(JsonSchemaForNpmPackageJsonFilesBugs) || t == typeof(JsonSchemaForNpmPackageJsonFilesBugs?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesBugs { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffyBugs>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesBugs { FluffyBugs = objectValue };
            }
            throw new Exception("Cannot unmarshal type JsonSchemaForNpmPackageJsonFilesBugs");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (JsonSchemaForNpmPackageJsonFilesBugs)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FluffyBugs != null)
            {
                serializer.Serialize(writer, value.FluffyBugs);
                return;
            }
            throw new Exception("Cannot marshal type JsonSchemaForNpmPackageJsonFilesBugs");
        }

        public static readonly JsonSchemaForNpmPackageJsonFilesBugsConverter Singleton = new JsonSchemaForNpmPackageJsonFilesBugsConverter();
    }

    [DoNotReorderFields]
    internal class JsonSchemaForNpmPackageJsonFilesExportsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(JsonSchemaForNpmPackageJsonFilesExports) || t == typeof(JsonSchemaForNpmPackageJsonFilesExports?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new JsonSchemaForNpmPackageJsonFilesExports { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesExports { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffyPackageExportsEntryObject>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesExports { FluffyPackageExportsEntryObject = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<PackageExportsEntry[]>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesExports { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type JsonSchemaForNpmPackageJsonFilesExports");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (JsonSchemaForNpmPackageJsonFilesExports)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.FluffyPackageExportsEntryObject != null)
            {
                serializer.Serialize(writer, value.FluffyPackageExportsEntryObject);
                return;
            }
            throw new Exception("Cannot marshal type JsonSchemaForNpmPackageJsonFilesExports");
        }

        public static readonly JsonSchemaForNpmPackageJsonFilesExportsConverter Singleton = new JsonSchemaForNpmPackageJsonFilesExportsConverter();
    }

    [DoNotReorderFields]
    internal class ManConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Man) || t == typeof(Man?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Man { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new Man { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Man");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Man)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Man");
        }

        public static readonly ManConverter Singleton = new ManConverter();
    }

    [DoNotReorderFields]
    internal class MinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 214)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 214)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }
    
    [DoNotReorderFields]
    internal class PrivateUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PrivateUnion) || t == typeof(PrivateUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new PrivateUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "false":
                            return new PrivateUnion { Enum = PrivateEnum.False };
                        case "true":
                            return new PrivateUnion { Enum = PrivateEnum.True };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type PrivateUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PrivateUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case PrivateEnum.False:
                        serializer.Serialize(writer, "false");
                        return;
                    case PrivateEnum.True:
                        serializer.Serialize(writer, "true");
                        return;
                }
            }
            throw new Exception("Cannot marshal type PrivateUnion");
        }

        public static readonly PrivateUnionConverter Singleton = new PrivateUnionConverter();
    }

    [DoNotReorderFields]
    internal class PrivateEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PrivateEnum) || t == typeof(PrivateEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "false":
                    return PrivateEnum.False;
                case "true":
                    return PrivateEnum.True;
            }
            throw new Exception("Cannot unmarshal type PrivateEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PrivateEnum)untypedValue;
            switch (value)
            {
                case PrivateEnum.False:
                    serializer.Serialize(writer, "false");
                    return;
                case PrivateEnum.True:
                    serializer.Serialize(writer, "true");
                    return;
            }
            throw new Exception("Cannot marshal type PrivateEnum");
        }

        public static readonly PrivateEnumConverter Singleton = new PrivateEnumConverter();
    }

    [DoNotReorderFields]
    internal class AccessConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Access) || t == typeof(Access?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "public":
                    return Access.Public;
                case "restricted":
                    return Access.Restricted;
            }
            throw new Exception("Cannot unmarshal type Access");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Access)untypedValue;
            switch (value)
            {
                case Access.Public:
                    serializer.Serialize(writer, "public");
                    return;
                case Access.Restricted:
                    serializer.Serialize(writer, "restricted");
                    return;
            }
            throw new Exception("Cannot marshal type Access");
        }

        public static readonly AccessConverter Singleton = new AccessConverter();
    }

    [DoNotReorderFields]
    internal class JsonSchemaForNpmPackageJsonFilesRepositoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(JsonSchemaForNpmPackageJsonFilesRepository) || t == typeof(JsonSchemaForNpmPackageJsonFilesRepository?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesRepository { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleRepository>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesRepository { PurpleRepository = objectValue };
            }
            throw new Exception("Cannot unmarshal type JsonSchemaForNpmPackageJsonFilesRepository");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (JsonSchemaForNpmPackageJsonFilesRepository)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.PurpleRepository != null)
            {
                serializer.Serialize(writer, value.PurpleRepository);
                return;
            }
            throw new Exception("Cannot marshal type JsonSchemaForNpmPackageJsonFilesRepository");
        }

        public static readonly JsonSchemaForNpmPackageJsonFilesRepositoryConverter Singleton = new JsonSchemaForNpmPackageJsonFilesRepositoryConverter();
    }

    [DoNotReorderFields]
    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "commonjs":
                    return TypeEnum.Commonjs;
                case "module":
                    return TypeEnum.Module;
                case "library":
                    return TypeEnum.Library;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Commonjs:
                    serializer.Serialize(writer, "commonjs");
                    return;
                case TypeEnum.Module:
                    serializer.Serialize(writer, "module");
                    return;
                case TypeEnum.Library:
                    serializer.Serialize(writer, "library");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    [DoNotReorderFields]
    internal class JsonSchemaForNpmPackageJsonFilesWorkspacesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(JsonSchemaForNpmPackageJsonFilesWorkspaces) || t == typeof(JsonSchemaForNpmPackageJsonFilesWorkspaces?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleWorkspaces>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesWorkspaces { PurpleWorkspaces = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new JsonSchemaForNpmPackageJsonFilesWorkspaces { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type JsonSchemaForNpmPackageJsonFilesWorkspaces");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (JsonSchemaForNpmPackageJsonFilesWorkspaces)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.PurpleWorkspaces != null)
            {
                serializer.Serialize(writer, value.PurpleWorkspaces);
                return;
            }
            throw new Exception("Cannot marshal type JsonSchemaForNpmPackageJsonFilesWorkspaces");
        }

        public static readonly JsonSchemaForNpmPackageJsonFilesWorkspacesConverter Singleton = new JsonSchemaForNpmPackageJsonFilesWorkspacesConverter();
    }

    [DoNotReorderFields]
    internal class NpmPackageRepositoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NpmPackageRepository) || t == typeof(NpmPackageRepository?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new NpmPackageRepository { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffyRepository>(reader);
                    return new NpmPackageRepository { FluffyRepository = objectValue };
            }
            throw new Exception("Cannot unmarshal type NpmPackageRepository");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NpmPackageRepository)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.FluffyRepository != null)
            {
                serializer.Serialize(writer, value.FluffyRepository);
                return;
            }
            throw new Exception("Cannot marshal type NpmPackageRepository");
        }

        public static readonly NpmPackageRepositoryConverter Singleton = new NpmPackageRepositoryConverter();
    }

    [DoNotReorderFields]
    internal class NpmPackageWorkspacesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NpmPackageWorkspaces) || t == typeof(NpmPackageWorkspaces?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FluffyWorkspaces>(reader);
                    return new NpmPackageWorkspaces { FluffyWorkspaces = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new NpmPackageWorkspaces { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type NpmPackageWorkspaces");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NpmPackageWorkspaces)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.FluffyWorkspaces != null)
            {
                serializer.Serialize(writer, value.FluffyWorkspaces);
                return;
            }
            throw new Exception("Cannot marshal type NpmPackageWorkspaces");
        }

        public static readonly NpmPackageWorkspacesConverter Singleton = new NpmPackageWorkspacesConverter();
    }
}
